+++
title = "创建Python 3.3+的软件包时是否需要__init__.py文件"
slug = "创建Python 3.3+的软件包时是否需要__init__.py文件"
date = "2023-09-06T14:35:31+08:00"
tags = [ "package", "python-3.x", "python",]
thumbnail = "/images/python-3.x.256x256.png"
featureImage = "/images/python-3.x.256x256.png"
+++


## 摘要

在Python 3.3+中创建软件包时，是否需要一个空的`__init__.py`文件呢？本教程将回答这个问题。通过查看Python文档中关于软件包的说明，并提供示例代码来解释为什么在大多数情况下仍建议保留`__init__.py`文件。

## 内容

在Python中，创建软件包时，通常会在每个包目录中包含一个`__init__.py`文件。这个文件的存在通常用于指示该目录是一个包。然而，从Python 3.3版本开始，引入了隐式命名空间包的概念，允许在不包含`__init__.py`文件的情况下创建软件包。

然而，需要注意的是，大多数开发者仍然建议在创建软件包时保留空的`__init__.py`文件。这么做的原因有以下几点：

1. 兼容性：保留`__init__.py`文件可以确保你的软件包与现有的源代码和项目指南保持兼容。
  
2. 明确性：有`__init__.py`文件可以让人更清楚地知道所在目录是一个软件包，而不会产生误解或困惑。

只有在需要使用隐式命名空间包的特殊情况下，才建议省略`__init__.py`文件。隐式命名空间包主要用于在多个位置分散保存的库之间共享命名空间。这种情况下，你可以在不同的目录中使用命名空间包共享相同的命名空间，而无需在每个目录中都包含`__init__.py`文件。

以下是一个示例，演示了创建隐式命名空间包和常规包的区别：

```
# 隐式命名空间包
google_pubsub/              <- 包1
    google/                 <- 命名空间包（不包含__init__.py）
        cloud/              <- 命名空间包（不包含__init__.py）
            pubsub/         <- 常规包（包含__init__.py）
                __init__.py <- 使该目录变为常规包所需的文件
                foo.py

google_storage/             <- 包2
    google/                 <- 命名空间包（不包含__init__.py）
        cloud/              <- 命名空间包（不包含__init__.py）
            storage/        <- 常规包（包含__init__.py）
                __init__.py <- 使该目录变为常规包所需的文件
                bar.py
```

需要注意的是，在使用`find_packages()`函数时，如果你希望包能够自动被发现，仍需要在每个目录中包含空的`__init__.py`文件。这是因为Python的工具（如`mypy`和`pytest`）在解析代码结构时，需要通过`__init__.py`文件来识别和解析包内部的模块和子包。如果没有这个文件，可能会导致一些奇怪的错误。

## 总结

在大多数情况下，建议在创建Python软件包时保留空的`__init__.py`文件。隐式命名空间包仅在需要与不同位置分散保存的库共享命名空间时使用。为了更好地兼容和遵循项目的约定，请始终保持空的`__init__.py`文件。

参考资料：
- [PEP 420](https://www.python.org/dev/peps/pep-0420/)
- [Python官方文档 - The import system](https://docs.python.org/3/reference/import.html)



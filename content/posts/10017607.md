+++
title = "在C++中显式初始化指针向量会导致转换错误吗？"
slug = "在C++中显式初始化指针向量会导致转换错误吗？"
date = "2023-07-24T14:15:41+08:00"
tags = [ "c++", "visual-c++",]
thumbnail = "/images/c++.256x256.png"
featureImage = "/images/c++.256x256.png"
+++


> 本教程将介绍在C++中显式初始化指针向量是否导致转换错误，并提供了相关示例和解释。

## 概述

考虑以下代码：

```cpp
stdvector<int*> v(1, 0);
```

在VC++10下编译成功（即使在最高警告级别下也没有警告）。然而，在Mac上的llvm或Linux上的gcc下，无法编译通过，并显示错误信息"assigning to int* from incompatible type const int." 我不需要解决方案 - 我知道第二个参数是不必要的，或者可以通过static_cast来修复错误。

我原以为零可以隐式转换为任何指针类型。这是怎么回事？我还可以执行以下操作：

```cpp
int* i = 0;
int* const& ii = 0;
const int t = 0;
i = t;
```

我知道vector的构造函数签名采用<code>const T&</code>，在展开为<code>vector<int*></code>时变为<code>int* const&</code>。有人能解释这里发生了什么，并判断VC++和非VC++编译器哪个是正确的吗？

看起来g++实际上是错误的。参考C++98标准23.1.1/9：

> 对于本节和第21节定义的每个序列：
> 
> - 构造函数模板<code>X(InputIterator f, InputIterator l, const Allocator&amp; a = Allocator())</code>的效果应与<code>X(static_cast&lt;typename X::size_type&gt;(f), static_cast&lt;typename X::value_type&gt;(l), a)</code>相同，其中InputIterator是整数类型。

请注意，<code>InputIterator</code>是构造函数的模板参数，在这种情况下，对于您的示例来说将是<code>int</code>，因此是整数类型。 g++库实际上有特定的代码来处理存储在<code>vector</code>中的类型为整数的所有情况，并且这些情况都可以正常工作。在这种情况下，只有因为您使用了<code>0</code>才会使标准要求的<code>static_cast</code>实际上是合法的。我尝试编译标准规定的等效代码，它可以在g++ 4.5中编译通过。



<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sql on 技术分享站</title>
    <link>https://www.techdocdb.com/tags/sql/</link>
    <description>Recent content in sql on 技术分享站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Sun, 10 Sep 2023 16:33:04 +0800</lastBuildDate><atom:link href="https://www.techdocdb.com/tags/sql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SQL Server中查询大于指定日期的所有日期</title>
      <link>https://www.techdocdb.com/posts/sql-server%E4%B8%AD%E6%9F%A5%E8%AF%A2%E5%A4%A7%E4%BA%8E%E6%8C%87%E5%AE%9A%E6%97%A5%E6%9C%9F%E7%9A%84%E6%89%80%E6%9C%89%E6%97%A5%E6%9C%9F/</link>
      <pubDate>Sun, 10 Sep 2023 16:33:04 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/sql-server%E4%B8%AD%E6%9F%A5%E8%AF%A2%E5%A4%A7%E4%BA%8E%E6%8C%87%E5%AE%9A%E6%97%A5%E6%9C%9F%E7%9A%84%E6%89%80%E6%9C%89%E6%97%A5%E6%9C%9F/</guid>
      <description>
        
          
            在SQL Server中，如果我们要查询大于某个日期的所有日期，我们需要注意日期的比较方式和格式。本文将介绍如何正确查询大于指定日期的所有日期，并提供了一些示例来说明。
摘要 当我们使用以下查询时，可能会导致无法得到期望的结果：
1SELECT * 2FROM dbo.March2010 A 3WHERE A.Date &amp;gt;= 2010-04-01; 在这种查询中，2010-4-01被视为数学表达式，实际上读取的是：
1SELECT * 2FROM dbo.March2010 A 3WHERE A.Date &amp;gt;= 2005; 为了避免这个问题，我们需要将日期转换为正确的datetime格式，并使用单引号括起来。
内容 以下是正确查询大于指定日期的所有日期的示例：
1SELECT * 2FROM dbo.March2010 A 3WHERE A.Date &amp;gt;= Convert(datetime, &amp;#39;2010-04-01&amp;#39;); 在这个示例中，我们使用了Convert函数将日期字符串转换为datetime类型，并使用单引号将日期字符串括起来。
另外，如果我们想要更加简洁的查询方式，也可以使用以下查询语句：
1SELECT * 2FROM dbo.March2010 A 3WHERE A.Date &amp;gt;= &amp;#39;2010-04-01&amp;#39;; 这种方式的查询语句会自动将日期字符串转换为正确的datetime类型。
总结 通过本文的介绍，我们知道了在SQL Server中查询大于指定日期的所有日期的正确方式。我们需要将日期字符串转换为datetime类型，并使用单引号括起来。我们还提供了多种示例，供读者参考和使用。
因此，在SQL Server中查询大于指定日期的所有日期时，请根据本文介绍的方式进行操作，以获得正确的查询结果。
          
          
        
      </description>
    </item>
    
    <item>
      <title>解析平面表为树的最高效/优雅的方法是什么？</title>
      <link>https://www.techdocdb.com/posts/%E8%A7%A3%E6%9E%90%E5%B9%B3%E9%9D%A2%E8%A1%A8%E4%B8%BA%E6%A0%91%E7%9A%84%E6%9C%80%E9%AB%98%E6%95%88/%E4%BC%98%E9%9B%85%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Sat, 09 Sep 2023 09:34:25 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E8%A7%A3%E6%9E%90%E5%B9%B3%E9%9D%A2%E8%A1%A8%E4%B8%BA%E6%A0%91%E7%9A%84%E6%9C%80%E9%AB%98%E6%95%88/%E4%BC%98%E9%9B%85%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>
        
          
            假设你有一个存储有序树层次结构的平面表：
1Id Name ParentId Order 2 1 &amp;#39;Node 1&amp;#39; 0 10 3 2 &amp;#39;Node 1.1&amp;#39; 1 10 4 3 &amp;#39;Node 2&amp;#39; 0 20 5 4 &amp;#39;Node 1.1.1&amp;#39; 2 10 6 5 &amp;#39;Node 2.1&amp;#39; 3 10 7 6 &amp;#39;Node 1.2&amp;#39; 1 20 你可以通过以下方式将其正确排序、正确缩进到HTML（或文本）中：
根节点0是虚构的根节点。
下面是一个图表，其中我们使用[id] Name。
1 [0] ROOT 2 / \ 3 [1] Node 1 [3] Node 2 4 / \ \ 5 [2] Node 1.1 [6] Node 1.2 [5] Node 2.
          
          
        
      </description>
    </item>
    
    <item>
      <title>&lt;html&gt;</title>
      <link>https://www.techdocdb.com/posts/html/</link>
      <pubDate>Fri, 08 Sep 2023 10:26:49 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/html/</guid>
      <description>
        
          
            504 Gateway Time-out 504 Gateway Time-out nginx 
          
          
        
      </description>
    </item>
    
    <item>
      <title>在MySQL中如何进行区分大小写的字符串比较？</title>
      <link>https://www.techdocdb.com/posts/%E5%9C%A8mysql%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/</link>
      <pubDate>Fri, 08 Sep 2023 01:20:11 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E5%9C%A8mysql%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/</guid>
      <description>
        
          
            摘要 本文介绍了在MySQL中如何进行区分大小写的字符串比较。
内容 有时候我们需要在MySQL中进行区分大小写的字符串比较。以下是几种实现区分大小写字符串比较的方法：
使用BINARY关键字
1SELECT * FROM `table` WHERE BINARY `column` = &amp;#39;value&amp;#39; 这个方法使用BINARY关键字对进行比较的列和值进行二进制比较，从而实现区分大小写的比较。
使用COLLATE关键字
1SELECT * FROM `table` WHERE `column` COLLATE utf8_bin = &amp;#39;value&amp;#39; 这个方法使用COLLATE关键字指定列和值的字符集和排序规则，从而实现区分大小写的比较。请将utf8_bin替换为您要使用的字符集和排序规则。
使用REGEXP_LIKE函数
1SELECT * FROM `table` WHERE REGEXP_LIKE(`column`, &amp;#39;value&amp;#39;, &amp;#39;c&amp;#39;) 这个方法使用REGEXP_LIKE函数进行区分大小写的正则表达式匹配。第三个参数指定了匹配类型为c，表示区分大小写的匹配。
请注意，在执行区分大小写的字符串比较时，请确保您的列和值都使用了正确的字符集和排序规则。
总结 本文介绍了在MySQL中进行区分大小写的字符串比较的方法。通过使用BINARY关键字、COLLATE关键字和REGEXP_LIKE函数，我们可以实现区分大小写的字符串比较。在处理需要区分大小写的字符串比较时，请选择适合的方法来满足您的需求。希望本文对您有所帮助，让您了解如何在MySQL中进行区分大小写的字符串比较。
          
          
        
      </description>
    </item>
    
    <item>
      <title>SQL Server中的SELECT INTO现有表的插入操作</title>
      <link>https://www.techdocdb.com/posts/sql-server%E4%B8%AD%E7%9A%84select-into%E7%8E%B0%E6%9C%89%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 06 Sep 2023 16:49:34 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/sql-server%E4%B8%AD%E7%9A%84select-into%E7%8E%B0%E6%9C%89%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</guid>
      <description>
        
          
            摘要 在SQL Server中，如果您想要从一个表中选择某些字段，并将它们插入到现有表中，可以使用INSERT INTO SELECT语句。本教程将介绍如何执行这样的操作，并提供使用示例。
内容 如果您想要将一个表中的多行数据插入到另一个现有表中，有几种方法可以实现：
使用INSERT INTO SELECT语句插入数据 在SQL Server中，可以使用INSERT INTO SELECT语句将数据从一个表插入到另一个表。下面是一个示例，展示了如何执行这样的操作：
1INSERT INTO dbo.TableTwo 2SELECT col1, col2 3FROM dbo.TableOne 4WHERE col3 LIKE @search_key 如果目标表（TableTwo）中的列与SELECT语句中的列相匹配，则不必指定列名。但为了可读性和可扩展性的原因，最好始终指定列名。例如：
1INSERT INTO dbo.TableTwo 2(col1, col2) 3SELECT col1, col2 4FROM dbo.TableOne 5WHERE col3 LIKE @search_key 使用SELECT INTO创建新表并插入数据 另一种方法是使用SELECT INTO语句创建一个新表，并从另一个表中选择和插入数据。新表将以与SELECT语句中所选列相同的数据类型创建。
下面是一个示例，展示了如何执行这样的操作：
1SELECT col1, col2 2INTO dbo.TableTwo 3FROM dbo.TableOne 4WHERE col3 LIKE @search_key 使用特定列插入数据 如果目标表中有多个列，并且和源表中的列不完全匹配，可以使用以下示例中的方法在插入数据时指定列名：
1INSERT INTO dbo.TABLETWO 2(col1, col2) 3SELECT col1, col2 4FROM dbo.TABLEONE 5WHERE col3 LIKE @search_key 这个示例假设dbo.
          
          
        
      </description>
    </item>
    
    <item>
      <title>在SQL Server中获取表的列名</title>
      <link>https://www.techdocdb.com/posts/%E5%9C%A8sql-server%E4%B8%AD%E8%8E%B7%E5%8F%96%E8%A1%A8%E7%9A%84%E5%88%97%E5%90%8D/</link>
      <pubDate>Thu, 31 Aug 2023 08:51:47 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E5%9C%A8sql-server%E4%B8%AD%E8%8E%B7%E5%8F%96%E8%A1%A8%E7%9A%84%E5%88%97%E5%90%8D/</guid>
      <description>
        
          
            摘要 本文介绍如何通过查询获取SQL Server数据库表的所有列名。可以使用信息模式视图INFORMATION_SCHEMA.COLUMNS来实现此目的。
内容 可以使用以下查询语句查询获取SQL Server数据库表的列名：
1SELECT COLUMN_NAME 2FROM INFORMATION_SCHEMA.COLUMNS 3WHERE TABLE_NAME = &amp;#39;表名&amp;#39; 以上查询语句将返回指定表的所有列名。
总结 通过使用信息模式视图INFORMATION_SCHEMA.COLUMNS，可以查询获取SQL Server数据库表的列名。这种方法可以让您方便地获取表的所有列名，以便进行进一步的操作和处理。
参考文档：INFORMATION_SCHEMA.COLUMNS
          
          
        
      </description>
    </item>
    
    <item>
      <title>MySQL中 @variable 和 variable 有什么区别？</title>
      <link>https://www.techdocdb.com/posts/mysql%E4%B8%AD-@variable-%E5%92%8C-variable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 25 Aug 2023 08:49:31 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/mysql%E4%B8%AD-@variable-%E5%92%8C-variable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid>
      <description>
        
          
            摘要 本教程将介绍MySQL中 @variable 和 variable 之间的区别。我们将提供示例代码来说明这个问题。
内容 在MySQL中，@variable 表示一个用户定义的变量，你可以自定义变量名称。它们是松散类型的变量，在会话中可以初始化并保留其值，直到会话结束为止。
@variable 变量的前面带有 @ 符号，如 @var。你可以使用 SET 语句或在查询中初始化这个变量：
1SET @var = 1; 2 3SELECT @var2 := 2; 当你在MySQL中开发存储过程时，可以传递输入参数并声明局部变量：
1DELIMITER // 2 3CREATE PROCEDURE prc_test (var INT) 4BEGIN 5 DECLARE var2 INT; 6 SET var2 = 1; 7 SELECT var2; 8END; 9// 10 11DELIMITER ; 这些变量不需要任何前缀，并且仅在存储过程被调用时重新初始化，而会话特定的用户定义变量不会重新初始化。
总结 通过执行上述代码，你可以在MySQL中使用 @variable 和 variable 两种变量。@variable 是会话特定的用户定义变量，variable 是存储过程变量。它们在作用域和用途上有所不同。选择适合你需求的变量类型来进行 MySQL 编程，以提高代码的可读性和灵活性。
          
          
        
      </description>
    </item>
    
    <item>
      <title>在 MySQL 中临时禁用外键约束的方法</title>
      <link>https://www.techdocdb.com/posts/%E5%9C%A8-mysql-%E4%B8%AD%E4%B8%B4%E6%97%B6%E7%A6%81%E7%94%A8%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 24 Aug 2023 14:57:45 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E5%9C%A8-mysql-%E4%B8%AD%E4%B8%B4%E6%97%B6%E7%A6%81%E7%94%A8%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>
        
          
            摘要 本教程将介绍如何在 MySQL 中临时禁用约束。我们将使用示例代码来说明这个过程。
内容 在 MySQL 中，可以通过以下方法临时禁用约束：
使用DISABLE KEYS语句或 使用SET FOREIGN_KEY_CHECKS=0语句 在执行需要临时禁用约束的操作之前，使用其中一种方法来禁用约束。然后在操作完成后，再重新启用约束。
以下是示例代码：
1SET FOREIGN_KEY_CHECKS=0; 确保在操作完成后重新启用约束：
1SET FOREIGN_KEY_CHECKS=1; 总结 在 MySQL 中，可以使用DISABLE KEYS或SET FOREIGN_KEY_CHECKS=0语句来临时禁用外键约束。在需要临时禁用约束的操作前使用上述语句来禁用约束，操作完成后重新启用约束。使用这些方法，可以临时禁用约束来执行需要的操作，然后再恢复约束以确保数据的完整性。
          
          
        
      </description>
    </item>
    
  </channel>
</rss>

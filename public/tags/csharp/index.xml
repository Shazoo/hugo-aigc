<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>csharp on 技术分享站</title>
    <link>https://www.techdocdb.com/tags/csharp/</link>
    <description>Recent content in csharp on 技术分享站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Thu, 07 Sep 2023 11:42:34 +0800</lastBuildDate><atom:link href="https://www.techdocdb.com/tags/csharp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>解决JSON.NET的&#34;Self referencing loop detected for type&#34;错误</title>
      <link>https://www.techdocdb.com/posts/%E8%A7%A3%E5%86%B3json.net%E7%9A%84self-referencing-loop-detected-for-type%E9%94%99%E8%AF%AF/</link>
      <pubDate>Thu, 07 Sep 2023 11:42:34 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E8%A7%A3%E5%86%B3json.net%E7%9A%84self-referencing-loop-detected-for-type%E9%94%99%E8%AF%AF/</guid>
      <description>
        
          
            摘要 本教程将解释如何解决使用JSON.NET时出现的&amp;quot;Self referencing loop detected for type&amp;quot;错误。我们将介绍几种方法，包括使用JsonSerializerSettings和添加属性的JsonIgnore特性来解决循环引用的问题。
解决方法 以下是解决&amp;quot;Self referencing loop detected for type&amp;quot;错误的几种方法：
使用JsonSerializerSettings： 1JsonSerializerSettings 
          
          
        
      </description>
    </item>
    
    <item>
      <title>在C#中将字节数组写入文件</title>
      <link>https://www.techdocdb.com/posts/%E5%9C%A8c#%E4%B8%AD%E5%B0%86%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6/</link>
      <pubDate>Wed, 06 Sep 2023 17:31:42 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E5%9C%A8c#%E4%B8%AD%E5%B0%86%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6/</guid>
      <description>
        
          
            摘要 本教程将介绍如何在C#中将字节数组写入文件。您可以使用File.WriteAllBytes方法或FileStream类来实现这一目的。通过这些方法，您可以将字节数组保存为文件，以便在以后进行读取或处理。
内容 引言 在C#开发中，有时候我们需要将字节数组存储为文件。这可以用于保存接收到的数据，或将数据写入文件以供后续处理。本教程将介绍几种方法来实现这一目标。
解决方案：使用File.WriteAllBytes方法 File.WriteAllBytes是一个静态方法，它允许您直接将字节数组写入文件。以下是使用File.WriteAllBytes方法的示例代码：
1File.WriteAllBytes(string path, byte[] bytes); 解决方案：使用FileStream类 如果您想在写入文件的过程中有更多的灵活性，您可以使用FileStream类。使用FileStream类，您可以手动控制写入位置和写入的字节数。以下是使用FileStream类的示例代码：
1using (FileStream fs = new FileStream(&amp;#34;filename&amp;#34;, FileMode.OpenOrCreate)) 2{ 3 fs.Write(byteArray, 0, byteArray.Length); 4} 总结 通过使用File.WriteAllBytes方法或FileStream类，您可以将字节数组写入文件。File.WriteAllBytes方法提供了一种简单的方法，适用于大多数情况。而FileStream类则允许更多的灵活性和控制。希望本教程对您有所帮助。
          
          
        
      </description>
    </item>
    
    <item>
      <title>&#43;# C#中如何获取当前用户桌面的路径</title>
      <link>https://www.techdocdb.com/posts/&#43;#-c%23%E4%B8%AD%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E6%A1%8C%E9%9D%A2%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Wed, 06 Sep 2023 17:05:33 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/&#43;#-c%23%E4%B8%AD%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E6%A1%8C%E9%9D%A2%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
      <description>
        
          
            摘要 本教程将介绍如何在C#中获取当前用户桌面的路径。我们将讨论使用的方法，并提供示例代码演示它的用法。
内容 要在C#中获取当前用户桌面的路径，可以使用以下方法：
1string path = Environment.GetFolderPath(Environment.SpecialFolder.Desktop); 以上代码将返回当前用户桌面的路径。
总结 本教程介绍了在C#中获取当前用户桌面路径的方法。通过使用Environment.GetFolderPath(Environment.SpecialFolder.Desktop)方法，可以轻松获取当前用户桌面的路径。选择适当的方法，根据需要获取路径，并在代码中使用。
          
          
        
      </description>
    </item>
    
    <item>
      <title>使用字符串格式化显示带两位小数或整数的数字</title>
      <link>https://www.techdocdb.com/posts/%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%98%BE%E7%A4%BA%E5%B8%A6%E4%B8%A4%E4%BD%8D%E5%B0%8F%E6%95%B0%E6%88%96%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Mon, 04 Sep 2023 04:34:51 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%98%BE%E7%A4%BA%E5%B8%A6%E4%B8%A4%E4%BD%8D%E5%B0%8F%E6%95%B0%E6%88%96%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>
        
          
            摘要 本文将解释如何使用字符串格式化来显示带两位小数或整数的数字。将提供相关示例代码以阐明知识点。
内容 在开发中，当需要显示价格字段时，有时价格可以是100、100.99或100.9等不同形式。我们希望在价格输入小数时仅显示两位小数，例如100应显示为100，而100.2应显示为100.20，100.22应保持不变。
这里是一些实现这个需求的示例代码，使用了简单的字符串格式化：
1var price1 = 100; 2var formattedPrice1 = String.Format(&amp;#34;{0:#,##0}&amp;#34;, price1); // 输出：100 3 4var price2 = 100.2; 5var formattedPrice2 = String.Format(&amp;#34;{0:#,##0.00}&amp;#34;, price2); // 输出：100.20 6 7var price3 = 100.22; 8var formattedPrice3 = String.Format(&amp;#34;{0:#,##0.00}&amp;#34;, price3); // 输出：100.22 在上述代码中，我们使用了 {0:#,##0} 的格式化方式来满足需求。对于整数，我们简单地使用 {0:#,##0} 来格式化为整数形式，不显示小数位。对于带小数的数字，我们使用 {0:#,##0.00} 来格式化为两位小数形式。
总结 通过使用字符串格式化，我们可以轻松地实现将数字格式化为带两位小数或整数的形式。通过简单的字符串格式化，我们可以满足不同显示需求的要求，并将数字以符合预期的方式呈现给用户。
参考链接：无
          
          
        
      </description>
    </item>
    
    <item>
      <title>在ASP.NET中创建文件夹（文件夹不存在时）</title>
      <link>https://www.techdocdb.com/posts/%E5%9C%A8asp.net%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6/</link>
      <pubDate>Mon, 04 Sep 2023 03:27:36 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E5%9C%A8asp.net%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%97%B6/</guid>
      <description>
        
          
            摘要 本教程将介绍如何在ASP.NET中创建文件夹。我们将讨论使用System.IO.Directory.CreateDirectory函数来创建文件夹的方法，并给出一些示例代码。
内容 在ASP.NET应用程序中，有时我们需要在保存文件之前检查文件夹是否存在，并在文件夹不存在时创建它。以下是创建文件夹的常用方法。
方法1：使用System.IO.Directory.CreateDirectory函数 1string subPath = HttpContext.Current.Server.MapPath(@&amp;#34;~/Images/RequisitionBarCode/&amp;#34;); 2 3bool exists = System.IO.Directory.Exists(subPath); 4if(!exists) 5 System.IO.Directory.CreateDirectory(subPath); 使用System.IO.Directory.CreateDirectory函数可以根据指定的路径创建文件夹。我们首先检查文件夹是否存在，如果不存在，则调用CreateDirectory函数创建文件夹。
总结 在ASP.NET应用程序中创建文件夹的方法很简单。我们可以使用System.IO.Directory.CreateDirectory函数来检查文件夹是否存在并在不存在时创建它。根据您的需求和个人偏好选择适合的方法即可。
          
          
        
      </description>
    </item>
    
    <item>
      <title>&lt;!DOCTYPE html&gt;</title>
      <link>https://www.techdocdb.com/posts/doctype-html/</link>
      <pubDate>Fri, 01 Sep 2023 08:57:53 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/doctype-html/</guid>
      <description>
        
          
             Error PayloadTooLargeError: request entity too large
&amp;nbsp; &amp;nbsp;at readStream (/var/www/server/old2new3/node_modules/express/node_modules/raw-body/index.js:156:17)
&amp;nbsp; &amp;nbsp;at getRawBody (/var/www/server/old2new3/node_modules/express/node_modules/raw-body/index.js:109:12)
&amp;nbsp; &amp;nbsp;at read (/var/www/server/old2new3/node_modules/express/node_modules/body-parser/lib/read.js:79:3)
&amp;nbsp; &amp;nbsp;at jsonParser (/var/www/server/old2new3/node_modules/express/node_modules/body-parser/lib/types/json.js:135:5)
&amp;nbsp; &amp;nbsp;at Layer.handle (/var/www/server/old2new3/node_modules/express/lib/router/layer.js:95:5)
&amp;nbsp; &amp;nbsp;at trim_prefix (/var/www/server/old2new3/node_modules/express/lib/router/index.js:328:13)
&amp;nbsp; &amp;nbsp;at &amp;lt;anonymous&amp;gt; (/var/www/server/old2new3/node_modules/express/lib/router/index.js:286:9)
&amp;nbsp; &amp;nbsp;at Function.process_params (/var/www/server/old2new3/node_modules/express/lib/router/index.js:346:12)
&amp;nbsp; &amp;nbsp;at next (/var/www/server/old2new3/node_modules/express/lib/router/index.js:280:10)
&amp;nbsp; &amp;nbsp;at next (/var/www/server/old2new3/node_modules/express/lib/router/route.js:136:14) 
          
          
        
      </description>
    </item>
    
    <item>
      <title>如何去除.NET DateTime中的毫秒</title>
      <link>https://www.techdocdb.com/posts/%E5%A6%82%E4%BD%95%E5%8E%BB%E9%99%A4.net-datetime%E4%B8%AD%E7%9A%84%E6%AF%AB%E7%A7%92/</link>
      <pubDate>Mon, 28 Aug 2023 09:05:18 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E5%A6%82%E4%BD%95%E5%8E%BB%E9%99%A4.net-datetime%E4%B8%AD%E7%9A%84%E6%AF%AB%E7%A7%92/</guid>
      <description>
        
          
            摘要 本教程将介绍如何去除.NET DateTime中的毫秒。
内容 在.NET中，DateTime对象包含毫秒级的精度。有时，我们需要删除这些毫秒部分，以便与其他时间进行比较或进行相应的处理。
以下是一些常见的方法：
1DateTime dateTime = DateTime.Now; 2dateTime = new DateTime(dateTime.Ticks - (dateTime.Ticks % TimeSpan.TicksPerSecond), dateTime.Kind); 第二种方式更为简短：
1dateTime = dateTime.AddTicks(-(dateTime.Ticks % TimeSpan.TicksPerSecond)); 你也可以创建一个扩展方法来实现通用的去除毫秒部分的功能：
1public static class DateTimeExtensions 2{ 3 public static DateTime TruncateMilliseconds(this DateTime dateTime) 4 { 5 return dateTime.AddTicks(-(dateTime.Ticks % TimeSpan.TicksPerSecond)); 6 } 7} 使用方法如下：
1dateTime = dateTime.TruncateMilliseconds(); 总结 在.NET中，通过去除DateTime对象的毫秒部分，我们可以与其他时间进行比较或进行相应的处理。通过使用适当的方法，我们可以轻松地去除DateTime对象的毫秒部分。希望本教程对你了解如何去除.NET DateTime中的毫秒有所帮助！
          
          
        
      </description>
    </item>
    
    <item>
      <title>将Linq查询结果转换为字典</title>
      <link>https://www.techdocdb.com/posts/%E5%B0%86linq%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E5%85%B8/</link>
      <pubDate>Thu, 24 Aug 2023 13:12:20 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E5%B0%86linq%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E5%85%B8/</guid>
      <description>
        
          
            摘要 本教程将介绍如何将Linq查询结果转换为字典。我们将使用示例代码来说明这个过程。
内容 在C#中，将Linq查询结果转换为字典可以使用ToDictionary()方法。以下是一个示例：
1var dict = TableObj.Select(t =&amp;gt; new { t.Key, t.TimeStamp }) 2 .ToDictionary(t =&amp;gt; t.Key, t =&amp;gt; t.TimeStamp); 在上述示例中，我们使用ToDictionary()方法将Linq查询结果转换为字典。首先，我们从TableObj中选择Key和TimeStamp属性，然后使用ToDictionary()方法将它们转换为字典。
这样，你就可以将获取到的字典存储到dict变量中。
总结 通过使用ToDictionary()方法，可以方便地将Linq查询结果转换为字典。在使用ToDictionary()方法时，需要指定键和值的属性，并确保属性名称和类型与查询结果匹配。这样，你就可以快速将Linq查询结果转换为字典，以便后续处理。
          
          
        
      </description>
    </item>
    
  </channel>
</rss>

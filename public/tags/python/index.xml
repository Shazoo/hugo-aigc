<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on 技术分享站</title>
    <link>https://techdocdb.com/tags/python/</link>
    <description>Recent content in python on 技术分享站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Fri, 25 Aug 2023 08:17:25 +0800</lastBuildDate><atom:link href="https://techdocdb.com/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python代码为什么在函数中运行更快？</title>
      <link>https://techdocdb.com/posts/python%E4%BB%A3%E7%A0%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%90%E8%A1%8C%E6%9B%B4%E5%BF%AB/</link>
      <pubDate>Fri, 25 Aug 2023 08:17:25 +0800</pubDate>
      
      <guid>https://techdocdb.com/posts/python%E4%BB%A3%E7%A0%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%90%E8%A1%8C%E6%9B%B4%E5%BF%AB/</guid>
      <description>
        
          
            摘要 本教程将解释为什么将Python代码放在一个函数中可以提高代码的执行速度。我们将使用具体的例子来说明这个问题。
内容 在将代码放在函数中之前，先看一下不同情况的代码执行时间。
下面是将代码放在函数中的情况：
1def main(): 2 for i in xrange(10**8): 3 pass 4main() 运行结果如下（注：此处是在Linux的BASH中使用time函数进行计时）：
1real 0m1.841s 2user 0m1.828s 3sys 0m0.012s 而将相同的循环代码放在函数之外，则运行时间更长：
1for i in xrange(10**8): 2 pass 运行结果如下：
1real 0m4.543s 2user 0m4.524s 3sys 0m0.012s 为什么会出现这种情况呢？
总结 代码在函数中运行更快的原因是因为CPython的优化实现。在编译函数时，局部变量被存储在一个固定大小的数组中，而局部变量名则被分配给相应的索引。这种方式加快了对局部变量的访问速度。相比之下，全局变量的访问需要进行哈希查找等操作，速度相对较慢。
通过函数内外代码的比较，我们可以看到存储局部变量的方式比存储全局变量的方式更高效。此外，CPython还针对局部变量的访问进行了一定的优化，包括对下一个操作码的预测。这些优化减少了操作码执行的开销，进一步提高了代码的运行速度。
结合对字节码的分析和源代码的解释，我们可以更好地理解为什么将代码放在函数中可以提高其执行效率。
更多关于CPython虚拟机实现的信息可以参考Python的官方文档中关于CPython虚拟机的介绍。
          
          
        
      </description>
    </item>
    
    <item>
      <title>使用.otf 字体在网页中</title>
      <link>https://techdocdb.com/posts/%E4%BD%BF%E7%94%A8.otf-%E5%AD%97%E4%BD%93%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD/</link>
      <pubDate>Thu, 24 Aug 2023 16:15:55 +0800</pubDate>
      
      <guid>https://techdocdb.com/posts/%E4%BD%BF%E7%94%A8.otf-%E5%AD%97%E4%BD%93%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%AD/</guid>
      <description>
        
          
            摘要 本教程将介绍如何在网页中使用.otf 字体。我们将使用示例代码来说明这个过程。
内容 如果你需要在网页中使用.otf 字体，可以使用@font-face 规则来嵌入字体并在网页中使用。下面是一个示例代码：
1@font-face { 2 font-family: &amp;#39;YourFontName&amp;#39;; 3 src: url(&amp;#39;path/your-font.otf&amp;#39;) format(&amp;#39;opentype&amp;#39;); 4} 在以上代码中，我们使用@font-face 规则指定了字体文件的路径和格式。然后，你可以在网页中使用这种字体：
1body { 2 font-family: &amp;#39;YourFontName&amp;#39;, sans-serif; 3} 在这个示例中，我们将字体文件的路径和格式指定为.otf，并使用@font-face 规则嵌入字体。然后，我们将这种字体应用于整个网页的 body 元素。
请注意，为了使字体在所有浏览器中正常工作，你可能需要提供其他字体格式的备用选项，例如.woff 或.ttf 格式。这样可以确保在不同的浏览器上都可以正常显示字体。
总结 通过使用@font-face 规则，你可以在网页中使用.otf 字体。可以指定字体文件的路径和格式，并将其嵌入到网页中。如果需要在不同的浏览器上都正常显示字体，可以提供其他字体格式的备用选项。使用这种方法，你可以实现在网页中使用自定义.otf 字体。
          
          
        
      </description>
    </item>
    
    <item>
      <title>使用 pip 安装具有最小和最大版本范围的软件包</title>
      <link>https://techdocdb.com/posts/%E4%BD%BF%E7%94%A8-pip-%E5%AE%89%E8%A3%85%E5%85%B7%E6%9C%89%E6%9C%80%E5%B0%8F%E5%92%8C%E6%9C%80%E5%A4%A7%E7%89%88%E6%9C%AC%E8%8C%83%E5%9B%B4%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85/</link>
      <pubDate>Thu, 24 Aug 2023 15:33:02 +0800</pubDate>
      
      <guid>https://techdocdb.com/posts/%E4%BD%BF%E7%94%A8-pip-%E5%AE%89%E8%A3%85%E5%85%B7%E6%9C%89%E6%9C%80%E5%B0%8F%E5%92%8C%E6%9C%80%E5%A4%A7%E7%89%88%E6%9C%AC%E8%8C%83%E5%9B%B4%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85/</guid>
      <description>
        
          
            摘要 本教程将介绍如何使用 pip 在 Python 中安装具有最小和最大版本范围的软件包。我们将使用示例代码来说明这个过程。
内容 在 pip 中，可以使用版本范围来指定安装软件包的最小和最大版本要求。以下是一些常用的方法：
使用&amp;gt;=和&amp;lt;操作符来指定最小和最大版本范围，如pip install &amp;quot;package&amp;gt;=0.2,&amp;lt;0.3&amp;quot;。 使用~=操作符来指定兼容的发布版本，如pip install &amp;quot;package~=0.5.0&amp;quot;。 以下是一个示例代码：
1pip install &amp;#34;package&amp;gt;=0.2,&amp;lt;0.3&amp;#34; 在上述示例中，我们使用了&amp;gt;=操作符指定了最小版本要求为 0.2，并使用&amp;lt;操作符指定了最大版本要求为 0.3。这样，pip 会查找符合要求的最佳版本进行安装。
版本范围限定也可以在 pip 的 requirements 文件中使用：
1package&amp;gt;=0.2,&amp;lt;0.3 这样做可以确保按照要求安装满足版本范围要求的软件包。
总结 在使用 pip 安装软件包时，可以使用版本范围来指定最小和最大版本要求。可以使用&amp;gt;=和&amp;lt;操作符或者~=操作符来指定版本范围。这样可以保证安装符合要求的最佳版本，并满足最小和最大版本的要求。
          
          
        
      </description>
    </item>
    
    <item>
      <title>使用 Python 求多个集合的交集</title>
      <link>https://techdocdb.com/posts/%E4%BD%BF%E7%94%A8-python-%E6%B1%82%E5%A4%9A%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E4%BA%A4%E9%9B%86/</link>
      <pubDate>Thu, 24 Aug 2023 14:15:42 +0800</pubDate>
      
      <guid>https://techdocdb.com/posts/%E4%BD%BF%E7%94%A8-python-%E6%B1%82%E5%A4%9A%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E4%BA%A4%E9%9B%86/</guid>
      <description>
        
          
            摘要 本教程将介绍如何在 Python 中求多个集合的交集。我们将使用示例代码来说明这个过程。
内容 在 Python 中，有多种方法可以找到多个集合的交集。下面是一些常用的方法：
使用&amp;amp;操作符求两个集合的交集，如set1 &amp;amp; set2。 使用intersection()方法求多个集合的交集，如set.intersection(set1, set2, set3)。 以下是一个示例代码：
1set1 = {1, 2, 3, 4, 5} 2set2 = {2, 3, 8, 9} 3set3 = {2, 10, 11, 12} 4 5intersection = set1 &amp;amp; set2 &amp;amp; set3 6print(intersection) 在上述示例中，我们定义了三个集合set1、set2和set3，然后使用&amp;amp;操作符求取它们的交集。最后，将交集打印出来。
使用intersection()方法也可以等效地求取多个集合的交集：
1intersection = set.intersection(set1, set2, set3) 2print(intersection) 这种方法更加灵活，可以适用于任意数量的集合。
总结 在 Python 中，可以使用&amp;amp;操作符或intersection()方法求取多个集合的交集。使用&amp;amp;操作符对两个集合求交集，使用intersection()方法对多个集合求交集。这些方法都可以在 Python 中方便地求取多个集合的交集，并返回一个新的集合作为结果。
          
          
        
      </description>
    </item>
    
    <item>
      <title>Python中定义类变量的正确方法</title>
      <link>https://techdocdb.com/posts/python%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 24 Aug 2023 13:17:56 +0800</pubDate>
      
      <guid>https://techdocdb.com/posts/python%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E6%B3%95/</guid>
      <description>
        
          
            摘要 本教程将介绍在Python中定义类变量的两种不同方法。我们将通过代码示例说明这两种方法的区别和使用场景。
内容 在Python中，我们可以使用两种不同的方法来初始化类变量。
在类内部直接初始化 第一种方法是在类内部直接初始化类变量。这样的类变量是属于类本身的，而不是属于对象的。以下是一个示例：
1class MyClass: 2 __element1 = 123 3 __element2 = &amp;#34;this is Africa&amp;#34; 4 5 def __init__(self): 6 #pass or something else 在上述示例中，我们直接在类内部定义了__element1和__element2这两个类变量。这些变量属于类本身，而不是属于对象。因此，它们是静态的，并且对于所有的对象来说都是相同的，可以在类外部通过MyClass.__element1的方式访问。
在__init__方法中初始化 第二种方法是在__init__方法中初始化类变量。这样的类变量是对象的一部分，每个对象都有自己的副本。以下是一个示例：
1class MyClass: 2 def __init__(self): 3 self.__element1 = 123 4 self.__element2 = &amp;#34;this is Africa&amp;#34; 在上述示例中，我们将__element1和__element2作为对象的实例变量来初始化。每个对象都会有自己的__element1和__element2，它们在各个对象之间是独立的。
总结 在Python中，我们可以采用不同的方法来定义类变量。直接在类内部定义的类变量是属于类本身的，它们对于所有的对象来说是相同的。而在__init__方法中定义的类变量是对象的一部分，它们会随着对象的创建而初始化，并且在各个对象之间是独立的。根据具体的需求，选择适合的方法来初始化类变量。
          
          
        
      </description>
    </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>recursion on 技术分享站</title>
    <link>https://www.techdocdb.com/tags/recursion/</link>
    <description>Recent content in recursion on 技术分享站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Sat, 09 Sep 2023 09:34:25 +0800</lastBuildDate><atom:link href="https://www.techdocdb.com/tags/recursion/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>解析平面表为树的最高效/优雅的方法是什么？</title>
      <link>https://www.techdocdb.com/posts/%E8%A7%A3%E6%9E%90%E5%B9%B3%E9%9D%A2%E8%A1%A8%E4%B8%BA%E6%A0%91%E7%9A%84%E6%9C%80%E9%AB%98%E6%95%88/%E4%BC%98%E9%9B%85%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Sat, 09 Sep 2023 09:34:25 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E8%A7%A3%E6%9E%90%E5%B9%B3%E9%9D%A2%E8%A1%A8%E4%B8%BA%E6%A0%91%E7%9A%84%E6%9C%80%E9%AB%98%E6%95%88/%E4%BC%98%E9%9B%85%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>
        
          
            假设你有一个存储有序树层次结构的平面表：
1Id Name ParentId Order 2 1 &amp;#39;Node 1&amp;#39; 0 10 3 2 &amp;#39;Node 1.1&amp;#39; 1 10 4 3 &amp;#39;Node 2&amp;#39; 0 20 5 4 &amp;#39;Node 1.1.1&amp;#39; 2 10 6 5 &amp;#39;Node 2.1&amp;#39; 3 10 7 6 &amp;#39;Node 1.2&amp;#39; 1 20 你可以通过以下方式将其正确排序、正确缩进到HTML（或文本）中：
根节点0是虚构的根节点。
下面是一个图表，其中我们使用[id] Name。
1 [0] ROOT 2 / \ 3 [1] Node 1 [3] Node 2 4 / \ \ 5 [2] Node 1.1 [6] Node 1.2 [5] Node 2.
          
          
        
      </description>
    </item>
    
    <item>
      <title>递归是否比循环更快？</title>
      <link>https://www.techdocdb.com/posts/%E9%80%92%E5%BD%92%E6%98%AF%E5%90%A6%E6%AF%94%E5%BE%AA%E7%8E%AF%E6%9B%B4%E5%BF%AB/</link>
      <pubDate>Wed, 06 Sep 2023 17:23:36 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E9%80%92%E5%BD%92%E6%98%AF%E5%90%A6%E6%AF%94%E5%BE%AA%E7%8E%AF%E6%9B%B4%E5%BF%AB/</guid>
      <description>
        
          
            摘要 本教程将讨论递归和循环的性能差异。我们会提供不同的编程语言和环境下的例子，来说明递归和循环的性能差异，并给出一些建议。
内容 在一般情况下，循环比递归更快。这主要是因为递归需要不断地建立和销毁栈帧，而循环只需要简单的跳转操作。递归的性能开销主要来自栈帧的建立和销毁，而循环只需要执行简单的跳转操作。
然而，性能差异也要考虑具体的编程语言和实现方式。在一些函数式编程语言中，递归可能更加高效，因为它可以被优化为简单的跳转操作。而在一些命令式编程语言中，循环可能更快，因为它更接近底层的机器指令。
总的来说，性能差异取决于具体的代码和实现方式。在选择递归或者循环时，应该首先考虑代码的可读性和可维护性。如果性能是关键因素，可以通过性能分析来确定是否需要优化，然后进行具体的优化策略。
总结 一般来说，循环比递归更快。循环只需要简单的跳转操作，而递归需要不断地建立和销毁栈帧，性能开销更大。然而，性能差异也取决于具体的编程语言和实现方式。在选择递归或者循环时，应该优先考虑代码的可读性和可维护性，如果性能是关键因素，可以进行具体的优化策略。
以上是关于递归和循环性能的讨论。根据具体的编程语言和环境，选择合适的编程方式并进行优化，以获得更好的性能。
          
          
        
      </description>
    </item>
    
  </channel>
</rss>

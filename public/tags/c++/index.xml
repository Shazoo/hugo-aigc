<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c&#43;&#43; on 技术分享站</title>
    <link>https://www.techdocdb.com/tags/c&#43;&#43;/</link>
    <description>Recent content in c&#43;&#43; on 技术分享站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Fri, 08 Sep 2023 10:18:33 +0800</lastBuildDate><atom:link href="https://www.techdocdb.com/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43;-FAQ：类型转换和类型转换规则</title>
      <link>https://www.techdocdb.com/posts/c&#43;&#43;-faq%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99/</link>
      <pubDate>Fri, 08 Sep 2023 10:18:33 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/c&#43;&#43;-faq%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99/</guid>
      <description>
        
          
            摘要 本文将介绍C++中常用的四种类型转换操作符：static_cast、dynamic_cast、const_cast和reinterpret_cast的使用场景和规则。对于每一种类型转换，我们将提供具体的用例和代码示例，让读者能够更好地理解和应用。
内容 static_cast的使用 static_cast是C++中最常用的类型转换操作符。它能够执行各种隐式转换和显式转换操作，包括数字类型之间的转换，以及类之间的上行转换（base class to derived class）。
用例：
1int i = 10; 2float f = static_cast&amp;lt;float&amp;gt;(i); // 隐式类型转换 3int j = static_cast&amp;lt;int&amp;gt;(3.14); // 显式类型转换 dynamic_cast的使用 dynamic_cast用于处理多态（polymorphism）的类型转换。只有在将指向派生类的指针或引用转换为指向基类的指针或引用时，才需要使用dynamic_cast。
用例：
1class Base { 2public: 3 virtual ~Base() {} 4}; 5 6class Derived : public Base { 7public: 8 void foo() {} 9}; 10 11void someFunction(Base* ptr) { 12 Derived* dptr = dynamic_cast&amp;lt;Derived*&amp;gt;(ptr); 13 if (dptr != nullptr) { 14 dptr-&amp;gt;foo(); 15 } 16} const_cast的使用 const_cast用于添加或移除const限定符。它只能用于转换指向非const对象的指针或引用。
          
          
        
      </description>
    </item>
    
    <item>
      <title>C&#43;&#43;中&#34;.&#34;运算符和&#34;-&gt;&#34;运算符的区别</title>
      <link>https://www.techdocdb.com/posts/c&#43;&#43;%E4%B8%AD.%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 04 Sep 2023 06:11:29 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/c&#43;&#43;%E4%B8%AD.%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>
        
          
            摘要 本教程将介绍C++中&amp;quot;.&amp;quot;运算符和&amp;quot;-&amp;gt;&amp;quot;运算符的区别。&amp;quot;.&amp;quot;运算符用于直接访问成员，而&amp;quot;-&amp;gt;&amp;quot;运算符用于首先解引用指针，然后访问所指向的对象的成员。
内容 &amp;quot;.&amp;quot;运算符和&amp;quot;-&amp;gt;&amp;quot;运算符的应用场景 在C++中，&amp;quot;.&amp;quot;运算符用于直接访问对象的成员，而&amp;quot;-&amp;gt;&amp;quot;运算符用于首先解引用指针，然后访问所指向的对象的成员。具体的使用场景如下所示：
&amp;quot;.&amp;quot;运算符用于访问对象的成员，例如：
1object.Field &amp;quot;-&amp;gt;&amp;quot;运算符用于解引用指针并访问所指向的对象的成员，例如：
1pClass-&amp;gt;Field 或者可以等价地写为：
1(*pClass).Field 示例代码 下面是一些示例代码，用来说明&amp;quot;.&amp;quot;运算符和&amp;quot;-&amp;gt;&amp;quot;运算符的用法。
1std::string str(&amp;#34;foo&amp;#34;); 2std::string * pstr = new std::string(&amp;#34;foo&amp;#34;); 3 4str.size (); 5pstr-&amp;gt;size (); 上述代码中，可以看到对于对象str，我们可以使用&amp;quot;.&amp;quot;运算符来访问其成员；而对于指针pstr，我们需要使用&amp;quot;-&amp;gt;&amp;quot;运算符来解引用指针并访问所指向的对象的成员。
注意事项 需要注意的是，&amp;quot;-&amp;gt;&amp;quot;运算符不能用于某些情况，例如访问operator[]运算符。
1#include &amp;lt;vector&amp;gt; 2 3int main() 4{ 5 std::vector&amp;lt;int&amp;gt; iVec; 6 iVec.push_back(42); 7 std::vector&amp;lt;int&amp;gt;* iVecPtr = &amp;amp;iVec; 8 9 //int i = iVecPtr-&amp;gt;[0]; // 无法编译通过 10 int i = (*iVecPtr)[0]; // 编译通过 11} 上述代码中，如果使用&amp;quot;-&amp;gt;&amp;quot;运算符访问operator[]运算符的话，无法编译通过，所以需要使用&amp;quot;(*iVecPtr)[0]&amp;quot;进行访问。
总结 本文介绍了C++中&amp;quot;.&amp;quot;运算符和&amp;quot;-&amp;gt;&amp;quot;运算符的区别和用法。&amp;quot;.&amp;quot;运算符用于直接访问对象的成员，而&amp;quot;-&amp;gt;&amp;quot;运算符用于首先解引用指针，然后访问所指向的对象的成员。希望本文能够帮助你理解和正确使用这两个运算符。
          
          
        
      </description>
    </item>
    
    <item>
      <title>使用Git查看特定文件的更改</title>
      <link>https://www.techdocdb.com/posts/%E4%BD%BF%E7%94%A8git%E6%9F%A5%E7%9C%8B%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6%E7%9A%84%E6%9B%B4%E6%94%B9/</link>
      <pubDate>Mon, 04 Sep 2023 00:02:19 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E4%BD%BF%E7%94%A8git%E6%9F%A5%E7%9C%8B%E7%89%B9%E5%AE%9A%E6%96%87%E4%BB%B6%E7%9A%84%E6%9B%B4%E6%94%B9/</guid>
      <description>
        
          
            概述 在日常开发中，我们经常需要查看某个文件在Git版本控制系统中的更改情况。本教程将介绍如何使用Git命令来查看特定文件的更改。
内容 要查看特定文件的更改，可以使用以下命令：
1git diff 文件名 这将显示特定文件的更改信息。git diff命令用于显示整个仓库的更改，但通过指定文件名，我们可以只显示特定文件的更改。
在使用git diff命令时，可以使用一些选项来进一步定制输出。例如，可以使用--color选项以着色方式显示更改，或者使用--stat选项以简洁的统计信息显示更改。
总结 通过使用git diff命令并指定文件名，我们可以轻松查看特定文件的更改。掌握这些技巧可以提
          
          
        
      </description>
    </item>
    
    <item>
      <title>在C&#43;&#43;中使用`noexcept`</title>
      <link>https://www.techdocdb.com/posts/%E5%9C%A8c&#43;&#43;%E4%B8%AD%E4%BD%BF%E7%94%A8noexcept/</link>
      <pubDate>Tue, 29 Aug 2023 08:34:13 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E5%9C%A8c&#43;&#43;%E4%B8%AD%E4%BD%BF%E7%94%A8noexcept/</guid>
      <description>
        
          
            摘要 本教程将介绍在C++中使用noexcept关键字的情况。通过示例代码和解释，演示了noexcept的使用场景和效果。
内容 noexcept关键字是C++11引入的特性之一。它用于指示一个函数不会抛出异常。在实
          
          
        
      </description>
    </item>
    
    <item>
      <title>C&#43;&#43;中存在头文件和.cpp文件的原因</title>
      <link>https://www.techdocdb.com/posts/c&#43;&#43;%E4%B8%AD%E5%AD%98%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C.cpp%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%9F%E5%9B%A0/</link>
      <pubDate>Thu, 24 Aug 2023 13:45:10 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/c&#43;&#43;%E4%B8%AD%E5%AD%98%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C.cpp%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%9F%E5%9B%A0/</guid>
      <description>
        
          
            摘要 本教程将解释为什么在C++中存在头文件和.cpp文件。我们将通过解释它们的作用和区别来回答这个问题。
内容 C++中存在头文件和.cpp文件的原因有以下几点：
分离接口和实现 头文件用于声明类或函数的接口，而.cpp文件则用于定义它们的实现。这种分离可以减少代码之间的依赖关系，使使用头文件的代码不需要了解实现的细节和其他类/头文件的信息。这样可以减少编译时间，以及在实现发生变化时所需的重新编译量。
提供链接信息 在C++中，最终的可执行代码不携带任何符号信息，而是纯粹的机器代码。因此，我们需要一种描述代码接口的方式，而不是将所有代码都放在一个文件中。这些描述信息通常存储在头文件中。
提供定义接口的方式 C++中，头文件用于声明接口，而.cpp文件用于定义实现。使用库的应用程序只需要了解和访问接口，可以通过#include指令进行访问。
总结 C++中存在头文件和.cpp文件主要是为了将接口与实现分离开来。头文件用于声明接口，而.cpp文件用于定义实现。这种分离可以减少代码依赖性，降低编译时间，并提供接口描述和链接信息。虽然不是完美的解决方案，但它是一种良好的起点，可以通过一些技术(比如Pimpl机制)来进一步将接口和实现分离。
          
          
        
      </description>
    </item>
    
    <item>
      <title>将std::string转换为int的方法</title>
      <link>https://www.techdocdb.com/posts/%E5%B0%86stdstring%E8%BD%AC%E6%8D%A2%E4%B8%BAint%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 24 Aug 2023 13:00:31 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E5%B0%86stdstring%E8%BD%AC%E6%8D%A2%E4%B8%BAint%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>
        
          
            摘要 本教程将介绍将std::string转换为int的几种方法。我们将通过使用代码示例来说明这些方法。
内容 在C++中，我们经常会遇到将字符串转换为整数的情况。以下是几种将std::string转换为int的方法。
使用std::stoi() 在C++11中，可以使用std::stoi()函数将字符串转换为整数。以下是一个示例：
1#include &amp;lt;iostream&amp;gt; 2#include &amp;lt;string&amp;gt; 3using namespace std; 4 5int main() 6{ 7 string str = &amp;#34;10&amp;#34;; 8 int number = std::stoi(str); 9 cout &amp;lt;&amp;lt; number &amp;lt;&amp;lt; endl; 10 11 return 0; 12} 在上述例子中，我们使用std::stoi()将字符串&amp;quot;10&amp;quot;转换为整数，并将结果打印输出。
使用字符串流(std::istringstream) 使用std::istringstream可以将字符串转换为整数。以下是一个示例：
1#include &amp;lt;iostream&amp;gt; 2#include &amp;lt;string&amp;gt; 3#include &amp;lt;sstream&amp;gt; 4using namespace std; 5 6int main() 7{ 8 string str = &amp;#34;10&amp;#34;; 9 int number; 10 std::istringstream(str) &amp;gt;&amp;gt; number; 11 cout &amp;lt;&amp;lt; number &amp;lt;&amp;lt; endl; 12 13 return 0; 14} 在上述例子中，我们使用std::istringstream将字符串&amp;quot;10&amp;quot;转换为整数。
          
          
        
      </description>
    </item>
    
  </channel>
</rss>

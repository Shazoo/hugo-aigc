<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bash on 技术分享站</title>
    <link>https://www.techdocdb.com/tags/bash/</link>
    <description>Recent content in bash on 技术分享站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Thu, 07 Sep 2023 16:00:48 +0800</lastBuildDate><atom:link href="https://www.techdocdb.com/tags/bash/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>在Shell脚本中进行逻辑OR运算的方法</title>
      <link>https://www.techdocdb.com/posts/%E5%9C%A8shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%BF%9B%E8%A1%8C%E9%80%BB%E8%BE%91or%E8%BF%90%E7%AE%97%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 07 Sep 2023 16:00:48 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E5%9C%A8shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%BF%9B%E8%A1%8C%E9%80%BB%E8%BE%91or%E8%BF%90%E7%AE%97%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>
        
          
            摘要 本教程将介绍如何在Shell脚本中进行逻辑OR运算。我们将讨论几种不同的方法，并提供具体的代码示例和说明。
内容 在Shell脚本中，有几种方式可以执行逻辑OR运算。以下是常用的方法：
使用||运算符：
使用 || 运算符可以在条件语句中执行逻辑OR运算。如果条件中的任一表达式为真，则整个条件为真。
1if [ &amp;#34;$#&amp;#34; -eq 0 ] || [ &amp;#34;$#&amp;#34; -gt 1 ] ; then 2 echo &amp;#34;hello&amp;#34; 3fi 使用 -o 或 -or：
使用 -o 或 -or 运算符也可以执行逻辑OR运算。如果条件中的任一表达式为真，则整个条件为真。
1if [ &amp;#34;$#&amp;#34; -eq 0 -o &amp;#34;$#&amp;#34; -gt 1 ] ; then 2 echo &amp;#34;hello&amp;#34; 3fi 使用 [[ ... ]]：
使用 [[ ... ]] 来包含条件语句，可以执行逻辑OR运算。与方括号 [ ... ] 不同，双方括号支持更多的逻辑操作符。
1if [[ &amp;#34;$#&amp;#34; -eq 0 || &amp;#34;$#&amp;#34; -gt 1 ]] ; then 2 echo &amp;#34;hello&amp;#34; 3fi 以上是在Shell脚本中执行逻辑OR运算的几种常见方法。根据具体的场景和需求，选择适合的方法来实现逻辑OR运算。
          
          
        
      </description>
    </item>
    
    <item>
      <title>在Bash中将stderr管道到另一个命令，而不是stdout</title>
      <link>https://www.techdocdb.com/posts/%E5%9C%A8bash%E4%B8%AD%E5%B0%86stderr%E7%AE%A1%E9%81%93%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%80%8C%E4%B8%8D%E6%98%AFstdout/</link>
      <pubDate>Thu, 07 Sep 2023 10:59:15 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E5%9C%A8bash%E4%B8%AD%E5%B0%86stderr%E7%AE%A1%E9%81%93%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%80%8C%E4%B8%8D%E6%98%AFstdout/</guid>
      <description>
        
          
            摘要 在Bash中，有时候我们想将stdout和stderr分别导向不同的命令进行处理。本教程将介绍如何使用命名管道(named pipes)实现这一目的，将stdout传递给一个命令，将stderr传递给另一个命令。
内容 要将stderr管道到另一个命令，可以按照以下步骤进行操作：
创建命名管道(named pipes)： 1mkfifo stdout-target 2mkfifo stderr-target 将stdout导向stdout-target管道，将stderr导向stderr-target管道，同时运行两个接收管道输入的命令： 1cat &amp;lt; stdout-target | command-for-stdout &amp;amp; 2cat &amp;lt; stderr-target | command-for-stderr &amp;amp; 运行主命令，将stdout导向stdout-target管道，将stderr导向stderr-target管道： 1main-command 1&amp;gt;stdout-target 2&amp;gt;stderr-target 运行完主命令后，记得删除命名管道： 1rm stdout-target stderr-target 总结 通过使用命名管道，我们可以将stdout和stderr分别导向不同的命令进行处理。这种方法比较灵活，可以将输出导向任何你想要的命令进行进一步处理。记得在使用命名管道后，及时删除它们，以避免占用过多的系统资源。
          
          
        
      </description>
    </item>
    
    <item>
      <title>使用Bash脚本中的自动错误退出</title>
      <link>https://www.techdocdb.com/posts/%E4%BD%BF%E7%94%A8bash%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E9%94%99%E8%AF%AF%E9%80%80%E5%87%BA/</link>
      <pubDate>Mon, 04 Sep 2023 06:00:26 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E4%BD%BF%E7%94%A8bash%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E9%94%99%E8%AF%AF%E9%80%80%E5%87%BA/</guid>
      <description>
        
          
            摘要 本教程将介绍如何在Bash脚本中实现自动错误退出。我们将提供多种解决方案，并通过示例代码演示每种解决方案的用法和效果。
内容 在编写Bash脚本时，有时候希望在任何命令失败时自动退出脚本。下面是几种解决方案：
解决方案1：使用set -e 在脚本
          
          
        
      </description>
    </item>
    
    <item>
      <title>在Python注释中的“# noqa”是什么意思？</title>
      <link>https://www.techdocdb.com/posts/%E5%9C%A8python%E6%B3%A8%E9%87%8A%E4%B8%AD%E7%9A%84#-noqa%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</link>
      <pubDate>Tue, 29 Aug 2023 09:55:04 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E5%9C%A8python%E6%B3%A8%E9%87%8A%E4%B8%AD%E7%9A%84#-noqa%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</guid>
      <description>
        
          
            摘要 本教程将介绍在Python注释中使用的“# noqa”的含义。
内容 当我们阅读Python项目时，经常会看到一些以“# noqa”注释的行。
1import sys 2sys.path.append(r&amp;#39;C:\dev&amp;#39;) 3import some_module # noqa 在Python中，“noqa”是什么意思？它是否只适用于Python？
在代码中添加“# noqa”表示代码检查工具将忽略这一行的检查。任何可能生成的警告将被忽略。
这一行可能包含一些“看起来不好”的代码，但开发人员理解并有意将其保留在代码中。
使用更多详细信息，请查看Flake8的“选择和忽略违规行为”文档。
希望本教程对你有所帮助！
参考答案：
What does &#39;# noqa&#39; mean in Python comments? 
          
          
        
      </description>
    </item>
    
    <item>
      <title>在目标机器上通过 ssh 执行后台命令</title>
      <link>https://www.techdocdb.com/posts/%E5%9C%A8%E7%9B%AE%E6%A0%87%E6%9C%BA%E5%99%A8%E4%B8%8A%E9%80%9A%E8%BF%87-ssh-%E6%89%A7%E8%A1%8C%E5%90%8E%E5%8F%B0%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Thu, 24 Aug 2023 14:32:09 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E5%9C%A8%E7%9B%AE%E6%A0%87%E6%9C%BA%E5%99%A8%E4%B8%8A%E9%80%9A%E8%BF%87-ssh-%E6%89%A7%E8%A1%8C%E5%90%8E%E5%8F%B0%E5%91%BD%E4%BB%A4/</guid>
      <description>
        
          
            摘要 本教程将介绍如何通过 ssh 在目标机器上执行后台命令。我们将使用示例代码来说明这个过程。
内容 在使用 ssh 在目标机器上执行后台命令时，有几种方法可以实现。
使用 nohup 命令来运行后台命令，并重定向输入输出，如nohup myprogram &amp;gt; foo.log 2&amp;gt; foo.err &amp;lt; /dev/null &amp;amp;。 使用 tmux 或 screen 等工具来创建一个持久化的会话，然后在会话中运行后台命令。 以下是一些示例代码：
使用 nohup 命令运行后台命令，并重定向输入输出： 1ssh user@target &amp;#34;cd /some/directory; nohup myprogram &amp;gt; foo.log 2&amp;gt; foo.err &amp;lt; /dev/null &amp;amp;&amp;#34; 在上述示例中，我们使用 cd 命令切换到目标目录，然后使用 nohup 命令运行 myprogram，并将输出重定向到 foo.log 文件，错误输出重定向到 foo.err 文件，然后将输入重定向到/dev/null，最后使用&amp;amp;符号将命令放入后台运行。
使用 tmux 或 screen 创建一个持久化的会话，并在会话中运行后台命令： 1ssh user@target &amp;#34;tmux new -d &amp;#39;cd /some/directory; nohup myprogram &amp;gt; foo.log 2&amp;gt; foo.err &amp;amp;&amp;#39;&amp;#34; 在上述示例中，我们使用 tmux 命令创建一个新的会话，并使用-c 选项指定要在会话中运行的命令。在命令中，我们首先使用 cd 命令切换到目标目录，然后使用 nohup 命令运行 myprogram，并将输出重定向到 foo.
          
          
        
      </description>
    </item>
    
  </channel>
</rss>

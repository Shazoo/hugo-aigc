<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on 技术分享站</title>
    <link>https://www.techdocdb.com/tags/java/</link>
    <description>Recent content in java on 技术分享站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright>
    <lastBuildDate>Wed, 06 Sep 2023 09:47:31 +0800</lastBuildDate><atom:link href="https://www.techdocdb.com/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>在匿名内部类中只有final变量是可访问的的原因</title>
      <link>https://www.techdocdb.com/posts/%E5%9C%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%AD%E5%8F%AA%E6%9C%89final%E5%8F%98%E9%87%8F%E6%98%AF%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%9A%84%E7%9A%84%E5%8E%9F%E5%9B%A0/</link>
      <pubDate>Wed, 06 Sep 2023 09:47:31 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E5%9C%A8%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%AD%E5%8F%AA%E6%9C%89final%E5%8F%98%E9%87%8F%E6%98%AF%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%9A%84%E7%9A%84%E5%8E%9F%E5%9B%A0/</guid>
      <description>
        
          
            摘要 在Java中，只有final变量可以在匿名内部类中访问。这篇文章将解释为什么只有final变量可以在匿名内部类中访问，并提供几种解决方案。
内容 在Java中，只有final变量可以在匿名内部类中访问。这是因为在匿名内部类中，当变量被匿名内部类引用时，其值被复制到内部类的实例中。这样做的目的是为了避免复杂的编译器生成代码来处理不同作用域变量的状态。
以下是解决这个问题的一些方法：
在变量前添加final关键字。 1private void f(Button b, final int a){ 2 b.addClickHandler(new ClickHandler() { 3 @Override 4 public void onClick(ClickEvent event) { 5 int b = a*5; 6 } 7 }); 8} 将变量提升为类级别的字段。 1class Example { 2 private int a; 3 4 private void f(Button b, int a) { 5 this.a = a; 6 7 b.addClickHandler(new ClickHandler() { 8 @Override 9 public void onClick(ClickEvent event) { 10 int b = Example.
          
          
        
      </description>
    </item>
    
    <item>
      <title>在Java中遍历HashMap</title>
      <link>https://www.techdocdb.com/posts/%E5%9C%A8java%E4%B8%AD%E9%81%8D%E5%8E%86hashmap/</link>
      <pubDate>Tue, 05 Sep 2023 23:53:21 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E5%9C%A8java%E4%B8%AD%E9%81%8D%E5%8E%86hashmap/</guid>
      <description>
        
          
            在Java中，遍历HashMap有多种方法。让我们来看看最常见的几种方法，以及它们的优缺点。由于所有的Map都实现了Map接口，下面的技术对于任何的Map实现（HashMap、TreeMap、LinkedHashMap、Hashtable等）都适用。
方法1：使用For-Each循环遍历entrySet 这是最常见的方法，在大多数情况下都是首选。如果在循环中需要同时使用Map的键和值，请使用这种方法。
1Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;Integer, Integer&amp;gt;(); 2for (Map.Entry&amp;lt;Integer, Integer&amp;gt; entry : map.entrySet()) { 3 System.out.println(&amp;#34;Key = &amp;#34; + entry.getKey() + &amp;#34;, Value = &amp;#34; + entry.getValue()); 4} 需要注意的是，For-Each循环是从Java 5版本引入的，所以只适用于较新的版本。此外，如果尝试对一个null的Map进行迭代，For-Each循环会抛出NullPointerException异常，因此在进行迭代之前应该始终检查null引用的情况。
方法2：使用For-Each循环遍历keySet或values 如果只需要Map的键或值，可以使用keySet或values方法进行迭代。
1Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;Integer, Integer&amp;gt;(); 2 3// 只迭代键 4for (Integer key : map.keySet()) { 5 System.out.println(&amp;#34;Key = &amp;#34; + key); 6} 7 8// 只迭代值 9for (Integer value : map.values()) { 10 System.out.println(&amp;#34;Value = &amp;#34; + value); 11} 这种方法相较于entrySet迭代略微提升了性能（大约快了10%），并且更简洁。
          
          
        
      </description>
    </item>
    
    <item>
      <title>Java 5中如何合并两个列表</title>
      <link>https://www.techdocdb.com/posts/java-5%E4%B8%AD%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8/</link>
      <pubDate>Sun, 03 Sep 2023 21:42:23 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/java-5%E4%B8%AD%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8/</guid>
      <description>
        
          
            概述 本教程将介绍如何在Java 5中合并两个列表。我们将使用具体的例子来说明这一过程。
合并两个列表 如果您想要合并两个列表，可以尝试以下几种方法：
使用addAll()方法： 你可以使用addAll()方法将一个列表中的元素添加到另一个列表中。例如：
1List&amp;lt;String&amp;gt; newList = new ArrayList&amp;lt;String&amp;gt;(); 2newList.addAll 
          
          
        
      </description>
    </item>
    
    <item>
      <title>在Java中如何确定一个数组是否包含特定的值？</title>
      <link>https://www.techdocdb.com/posts/%E5%9C%A8java%E4%B8%AD%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%89%B9%E5%AE%9A%E7%9A%84%E5%80%BC/</link>
      <pubDate>Tue, 29 Aug 2023 08:30:42 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E5%9C%A8java%E4%B8%AD%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%89%B9%E5%AE%9A%E7%9A%84%E5%80%BC/</guid>
      <description>
        
          
            摘要 本教程将介绍如何在Java中确定一个数组是否包含特定的值。
内容 您可以使用不同的方法来确定一个数组是否包含特定的值。以下是一些常用的方法：
使用Arrays.asList()方法： 1Arrays.asList(yourArray).contains(yourValue) 注意：这对于基本类型的数组不起作用（参见注释）。
使用Java 8中的流（Stream）： 1String[] values = {&amp;#34;AB&amp;#34;,&amp;#34;BC&amp;#34;,&amp;#34;CD&amp;#34;,&amp;#34;AE&amp;#34;}; 2boolean contains = Arrays.stream(values).anyMatch(&amp;#34;s&amp;#34;::equals); 对于基本类型的数组，请使用IntStream、DoubleStream或LongStream。
这些方法在判断数组是否包含特定值时都很有效。
总结 本教程介绍了在Java中确定数组是否包含特定值的方法。您可以使用Arrays.asList()方法或Java 8中的流（Stream）来进行判断。希望本教程对您理解如何在Java中判断数组是否包含特定值有所帮助！
          
          
        
      </description>
    </item>
    
    <item>
      <title>如何在 HashMap 中保留插入顺序?</title>
      <link>https://www.techdocdb.com/posts/%E5%A6%82%E4%BD%95%E5%9C%A8-hashmap-%E4%B8%AD%E4%BF%9D%E7%95%99%E6%8F%92%E5%85%A5%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>Fri, 25 Aug 2023 09:22:32 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E5%A6%82%E4%BD%95%E5%9C%A8-hashmap-%E4%B8%AD%E4%BF%9D%E7%95%99%E6%8F%92%E5%85%A5%E9%A1%BA%E5%BA%8F/</guid>
      <description>
        
          
            摘要 本教程将介绍如何在 HashMap 中保留插入顺序。我们将提供示例代码来说明这个问题。
内容 在使用 HashMap 时，遍历该映射时，数据的返回顺序通常是随机的。但是，有时我们需要保留插入的顺序。那么，我们该如何做到呢？
Java 提供了一个类
          
          
        
      </description>
    </item>
    
    <item>
      <title>在 Java 中使用 switch 语句和枚举</title>
      <link>https://www.techdocdb.com/posts/%E5%9C%A8-java-%E4%B8%AD%E4%BD%BF%E7%94%A8-switch-%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%9E%9A%E4%B8%BE/</link>
      <pubDate>Thu, 24 Aug 2023 12:31:06 +0800</pubDate>
      
      <guid>https://www.techdocdb.com/posts/%E5%9C%A8-java-%E4%B8%AD%E4%BD%BF%E7%94%A8-switch-%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%9E%9A%E4%B8%BE/</guid>
      <description>
        
          
            摘要 本教程将介绍如何在 Java 中使用 switch 语句和枚举。我们将使用示例代码来说明这个过程。
内容 在 Java 中，可以使用 switch 语句来进行多条件的比较。当与枚举一起使用时，可以更方便地处理不同的情况。
以下是一个示例代码：
1public class SomeClass { 2 3 public enum MyEnum { 4 VALUE_A, VALUE_B 5 } 6 7 public void someMethod() { 8 MyEnum enumExample = MyEnum.VALUE_A; 9 10 switch (enumExample) { 11 case VALUE_A: { 12 // 这里是 VALUE_A 的逻辑 13 break; 14 } 15 case VALUE_B: { 16 // 这里是 VALUE_B 的逻辑 17 break; 18 } 19 } 20 } 21} 在上述示例中，我们定义了一个枚举 MyEnum，它包含了两个枚举常量 VALUE_A 和 VALUE_B。在 someMethod 方法中，我们使用了 switch 语句来根据 enumExample 的值进行不同的逻辑处理。
          
          
        
      </description>
    </item>
    
  </channel>
</rss>
